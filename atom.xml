<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/iMHaoyu.github.io/atom.xml" rel="self"/>
  
  <link href="https://xuhaoyucn.com/"/>
  <updated>2018-12-20T02:43:38.003Z</updated>
  <id>https://xuhaoyucn.com/</id>
  
  <author>
    <name>xuhaoyu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS蓝牙外设的代码实现</title>
    <link href="https://xuhaoyucn.com/2018/12/20/%E8%93%9D%E7%89%99%E8%BF%9E%E6%8E%A5%E5%A4%96%E8%AE%BE%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>https://xuhaoyucn.com/2018/12/20/蓝牙连接外设的代码实现/</id>
    <published>2018-12-20T12:11:58.000Z</published>
    <updated>2018-12-20T02:43:38.003Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>时隔几个月再次拾起了我的博客（猛然发现我是有博客的人啊….），当然，最近还是挺累的，经过家里之前有些事情，回来后就格外的累，其次就是最近都没有什么可以记录的事情。当然，我没有把博客当作日记来记录，而是当作一个技术类来记录的，所以没有那么勤快。（此处只是借口…还是没有养成写博客的习惯）</p><p>废话不多说，最近学习了iOS的蓝牙模块，然后这里就根据<a href="https://github.com/iMHaoyu/HYBluetoothManager" target="_blank" rel="noopener">我的学习代码</a>来稍微总结一下iOS中心模式的应用场景。（PS:代码只是用来理解流程的，具体的可以看看大神封装的这个蓝牙库<a href="https://github.com/coolnameismy/BabyBluetooth" target="_blank" rel="noopener">BabyBluetooth</a>）中心模式：主设备是手机，用手机扫描连接外设，发现外设服务和属性，操作服务和属性的应用。这里的外设就是蓝牙设备，比如智能手环之类的东西。一般外设会由硬件工程师开发好，并定义好设备提供的服务，每个服务对于的特征，每个特征的属性（只读，只写，通知等等）。</p><p>本文例子的业务场景，就是用一手机app去读写蓝牙设备。</p></blockquote><h2 id="蓝牙基础知识"><a href="#蓝牙基础知识" class="headerlink" title="蓝牙基础知识"></a>蓝牙基础知识</h2><blockquote><p>CoreBluetooth框架的核心其实是两个东西，peripheral和central, 可以理解成外设和中心。对应他们分别有一组相关的API和类。</p><p>每个设备都会有一些服务，每个服务里面都会有一些特征，特征就是具体键值对，提供数据的地方。每个特征属性分为这么几种：读，写，通知这么几种方式。</p></blockquote><a id="more"></a><h2 id="连接蓝牙设备的流程"><a href="#连接蓝牙设备的流程" class="headerlink" title="连接蓝牙设备的流程"></a>连接蓝牙设备的流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">蓝牙开发没有想象中的难，首先在开发的前期我们需要知道蓝牙的整个工作流程，这样更容易理解。</span><br><span class="line">下面我来梳理一下蓝牙的实现流程，记住关键字。</span><br><span class="line"></span><br><span class="line">1. 建立中心角色 (CBCentralManager)</span><br><span class="line">2. 扫描外设（discover =&gt; CBPeripherals）</span><br><span class="line">3. 连接外设(connect)</span><br><span class="line">4. 扫描外设中的服务和特征(discover)</span><br><span class="line">    - 4.1. 获取外设的services(服务)</span><br><span class="line">    - 4.2. 获取外设的Characteristics(特征)</span><br><span class="line">    - 4.3. 获取Characteristics的值(特征值)</span><br><span class="line">    - 4.4. 获取Characteristics的Descriptor(特征的描述符)</span><br><span class="line">    - 4.5. 获取Characteristics的Descriptor的值(特征的描述符值)</span><br><span class="line">5. 与外设做数据交互(explore and interact)</span><br><span class="line">6. 订阅Characteristic的通知</span><br><span class="line">7. 断开连接(disconnect)</span><br></pre></td></tr></table></figure><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="1-导入CoreBluetooth头文件，建立主设备管理类，设置主设备委托"><a href="#1-导入CoreBluetooth头文件，建立主设备管理类，设置主设备委托" class="headerlink" title="1 导入CoreBluetooth头文件，建立主设备管理类，设置主设备委托"></a>1 导入CoreBluetooth头文件，建立主设备管理类，设置主设备委托</h3><p>导入头文件 <em>#import \&lt;CoreBluetooth/CoreBluetooth.h></em> 建立系统蓝牙设备管理对象（PS：可以把他理解为主设备，通过他，可以去扫描和链接外设）。我这里把他封装成了另外一个管理类（单例模式），这样可以更系统的看到整个的实现流程，后期有时间可能会封装的更加完整。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> @interface HYBluetooth ()&lt;CBCentralManagerDelegate,CBPeripheralDelegate&gt; &#123;</span><br><span class="line">    /** 系统蓝牙设备管理对象，可以把他理解为主设备，通过他，可以去扫描和链接外设 */</span><br><span class="line">    CBCentralManager *_centralManager;</span><br><span class="line"></span><br><span class="line">    /** 已经连接的外围设备 */</span><br><span class="line">    NSMutableArray&lt;CBPeripheral *&gt; *_connectedPeripherals;</span><br><span class="line">    /** 已经扫描到的外围设备 */</span><br><span class="line">    NSMutableArray&lt;CBPeripheral *&gt; *_discoverPeripherals;</span><br><span class="line">    /** 需要自动重新连接的外围设备 */</span><br><span class="line">    NSMutableArray&lt;CBPeripheral *&gt; *_reconnectPeripherals;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation HYBluetooth</span><br><span class="line">/** 单例模式 */</span><br><span class="line">+ (instancetype)hy_shareBluetooth &#123;</span><br><span class="line">    static HYBluetooth *bluetooth = nil;</span><br><span class="line">    static dispatch_once_t oneToken;</span><br><span class="line">    dispatch_once(&amp;oneToken, ^&#123;</span><br><span class="line">        bluetooth = [[HYBluetooth alloc]init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return bluetooth;</span><br><span class="line">&#125;</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line"></span><br><span class="line">        //初始化并设置代理和线程队列，最好一个线程的参数可以为nil，默认会就main线程</span><br><span class="line">        _centralManager = [[CBCentralManager alloc]initWithDelegate:self queue:nil];</span><br><span class="line">        _needDiscoverServices = YES;</span><br><span class="line"></span><br><span class="line">        _connectedPeripherals = [NSMutableArray array];</span><br><span class="line">        _discoverPeripherals = [NSMutableArray array];</span><br><span class="line">        _reconnectPeripherals = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，建立了管理类之后就需要实现他的代理方法了，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 必须实现的代理方法</span><br><span class="line">    //主设备状态改变的委托，在初始化CBCentralManager的适合会打开设备，只有当设备正确打开后才能使用其他选择实现的委托中比较重要的</span><br><span class="line">    - (void)centralManagerDidUpdateState:(CBCentralManager *)central</span><br><span class="line">2. 其他选择实现的委托中比较重要的：</span><br><span class="line">    //找到外设的委托</span><br><span class="line">    - (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI;</span><br><span class="line">    //连接外设成功的委托</span><br><span class="line">    - (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral;</span><br><span class="line">    //外设连接失败的委托</span><br><span class="line">    - (void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error;</span><br><span class="line">     //断开外设的委托</span><br><span class="line">    - (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error;</span><br></pre></td></tr></table></figure><h4 id="1-1-扫描外设（discover）"><a href="#1-1-扫描外设（discover）" class="headerlink" title="1.1 扫描外设（discover）"></a>1.1 扫描外设（discover）</h4><p>方法<code>- (void)centralManagerDidUpdateState:(CBCentralManager *)central</code>是必须实现的代理方法，该方法是自动回调用的方法，可以根据<code>central.state</code>来判断设备的蓝牙状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/** 设备的蓝牙状态是否打开，是否可用 */</span><br><span class="line">- (void)centralManagerDidUpdateState:(nonnull CBCentralManager *)central &#123;</span><br><span class="line"></span><br><span class="line">    switch (central.state) &#123;</span><br><span class="line">        case CBManagerStateUnknown:</span><br><span class="line">            NSLog(@&quot;&gt;&gt;&gt;初始的时候,未知的（刚刚创建的时候是未知的）&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case CBManagerStateResetting:</span><br><span class="line">            NSLog(@&quot;&gt;&gt;&gt;正在重置状态&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case CBManagerStateUnsupported:</span><br><span class="line">            NSLog(@&quot;&gt;&gt;&gt;设备不支持的状态&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case CBManagerStateUnauthorized:</span><br><span class="line">            NSLog(@&quot;&gt;&gt;&gt;程序未授权&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case CBManagerStatePoweredOff:</span><br><span class="line">            NSLog(@&quot;&gt;&gt;&gt;设备蓝牙关闭状态&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case CBManagerStatePoweredOn:</span><br><span class="line">        &#123;</span><br><span class="line">            NSLog(@&quot;&gt;&gt;&gt;设备蓝牙打开状态&quot;);</span><br><span class="line"></span><br><span class="line">            //扫描外设的方法我们放在centralManager成功打开的委托中(该方法)，因为只有设备成功打开，才能开始扫描，否则会报错。</span><br><span class="line">            //开始扫描周围的外设            /*</span><br><span class="line">             第一个参数nil就是扫描周围所有的外设，扫描到外设后会进入</span><br><span class="line">             - (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI;</span><br><span class="line">            */</span><br><span class="line">            [_centralManager scanForPeripheralsWithServices:nil options:nil];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //此处是我自己建立的单例类，用Block来实现回调，这样显的流程很清晰</span><br><span class="line">    if (self.centralManagerDidUpdateStateBlock) &#123;</span><br><span class="line">        self.centralManagerDidUpdateStateBlock(central);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 返回扫描到的蓝牙设备 的委托方法 （一个一个的返回，多次返回） */</span><br><span class="line">- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *,id&gt; *)advertisementData RSSI:(NSNumber *)RSSI &#123;</span><br><span class="line"></span><br><span class="line">    //把扫描到的设备添加到已扫描到的设备的数组中</span><br><span class="line">    //判断是否包含该设备</span><br><span class="line">    if (![_discoverPeripherals containsObject:peripheral]) &#123;</span><br><span class="line">        [_discoverPeripherals addObject:peripheral];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //此处是我自己建立的单例类，用Block来实现回调，这样显的流程很清晰</span><br><span class="line">    //扫描到设备的回调</span><br><span class="line">    if (self.didDiscoverPeripheralBlock) &#123;</span><br><span class="line">        self.didDiscoverPeripheralBlock(peripheral, advertisementData, RSSI);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-连接外设"><a href="#1-2-连接外设" class="headerlink" title="1.2 连接外设"></a>1.2 连接外设</h4><p>通过<code>[_centralManager connectPeripheral:peripheral options:nil];</code>,连接设备。</p><blockquote><p>一个主设备最多能连7个外设，每个外设最多只能给一个主设备连接,连接成功，失败，断开会进入各自的委托</p><blockquote><p>//连接外设成功的委托</p></blockquote><ul><li>(void)centralManager:(CBCentralManager <em>)central didConnectPeripheral:(CBPeripheral </em>)peripheral;</li></ul><blockquote><p>//外设连接失败的委托</p></blockquote><ul><li>(void)centralManager:(CBCentralManager <em>)central didFailToConnectPeripheral:(CBPeripheral </em>)peripheral error:(NSError *)error;</li></ul><blockquote><p>//断开外设的委托</p></blockquote><ul><li>(void)centralManager:(CBCentralManager <em>)central didDisconnectPeripheral:(CBPeripheral </em>)peripheral error:(NSError *)error;//断开外设的委托</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/** 连接到Peripheral-成功  */</span><br><span class="line">- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //设置的peripheral委托CBPeripheralDelegate</span><br><span class="line">    [peripheral setDelegate:self];</span><br><span class="line"></span><br><span class="line">    //添加已连接设备</span><br><span class="line">    [self addConnectedPeripheral:peripheral];</span><br><span class="line"></span><br><span class="line">    //此处是我自己建立的单例类，用Block来实现回调，这样显的流程很清晰</span><br><span class="line">    //已连接设备的回调</span><br><span class="line">    if (self.didConnectedPeripheralBlock) &#123;</span><br><span class="line">        self.didConnectedPeripheralBlock(central,peripheral);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //是否需要扫描服务</span><br><span class="line">    if (self.needDiscoverServices) &#123;</span><br><span class="line">        [peripheral discoverServices:nil];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 连接到Peripheral-失败 */</span><br><span class="line">- (void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">    //此处是我自己建立的单例类，用Block来实现回调，这样显的流程很清晰</span><br><span class="line">    //连接失败的回调</span><br><span class="line">    if (self.failToConnectPeripheralBlock) &#123;</span><br><span class="line">        self.failToConnectPeripheralBlock(central,peripheral,error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Peripherals断开连接 */</span><br><span class="line">- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; didDisconnectPeripheral for %@ with error: %@&quot;, peripheral.name, [error localizedDescription]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //从已连接的设备数组中删除该设备</span><br><span class="line">    //判断是否包含该设备</span><br><span class="line">    if ([_connectedPeripherals containsObject:peripheral]) &#123;</span><br><span class="line">        [_connectedPeripherals removeObject:peripheral];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //此处是我自己建立的单例类，用Block来实现回调，这样显的流程很清晰</span><br><span class="line">    //断开连接的回调</span><br><span class="line">    if (self.disconnectPeripheralBlock) &#123;</span><br><span class="line">        self.disconnectPeripheralBlock(central,peripheral,error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //检查并重新连接需要重连的设备</span><br><span class="line">    if ([_reconnectPeripherals containsObject:peripheral]) &#123;</span><br><span class="line">        [self hy_connectPeripheral:peripheral];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-扫描外设中的服务和特征-discover"><a href="#2-扫描外设中的服务和特征-discover" class="headerlink" title="2 扫描外设中的服务和特征(discover)"></a>2 扫描外设中的服务和特征(discover)</h3><p>到此，设备连接成功后，就可以扫描设备的服务了，同样是通过委托形式，扫描到结果后会进入委托方法。但是这个委托已经不再是主设备的委托（CBCentralManagerDelegate），而是外设的委托（CBPeripheralDelegate）,这个委托包含了主设备与外设交互的许多 回叫方法，包括获取services，获取characteristics，获取characteristics的值，获取characteristics的Descriptor，和Descriptor的值，写数据，读rssi，用通知的方式订阅数据等等。</p><h4 id="2-1-获取外设的services"><a href="#2-1-获取外设的services" class="headerlink" title="2.1 获取外设的services"></a>2.1 获取外设的services</h4><p>通过<code>[peripheral discoverServices:nil]</code>获取设备的服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/** 扫描到服务 */</span><br><span class="line">- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error &#123;</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt;didDiscoverServices for %@ with error: %@&quot;, peripheral.name, [error localizedDescription]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //此处是我自己建立的单例类，用Block来实现回调，这样显的流程很清晰</span><br><span class="line">    //扫描到服务的回调</span><br><span class="line">    if (self.discoverServicesBlock) &#123;</span><br><span class="line">        self.discoverServicesBlock(peripheral,error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-获取外设的Characteristics"><a href="#2-2-获取外设的Characteristics" class="headerlink" title="2.2 获取外设的Characteristics"></a>2.2 获取外设的Characteristics</h4><p>通过<code>[peripheral discoverCharacteristics:characteristics forService:service]</code>，扫描每个service的Characteristics。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** 扫描到服务的特征（Characteristics） */</span><br><span class="line">- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error &#123;</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt;error didDiscoverCharacteristicsForService for %@ with error: %@&quot;, service.UUID, [error localizedDescription]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.discoverCharacteristicsBlock) &#123;</span><br><span class="line">        self.discoverCharacteristicsBlock(peripheral,service,error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-获取Characteristics的值"><a href="#2-3-获取Characteristics的值" class="headerlink" title="2.3 获取Characteristics的值"></a>2.3 获取Characteristics的值</h4><p>通过<code>[peripheral readValueForCharacteristic:characteristic]</code>来读取数据不怎么更新的Characteristic的值,或通过<code>[peripheral setNotifyValue:enabled forCharacteristic:characteristic];</code>获取经常更新的Characteristic的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** 获取的charateristic的值 */</span><br><span class="line">- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123;</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt;error didUpdateValueForCharacteristic %@ with error: %@&quot;, characteristic.UUID, [error localizedDescription]);</span><br><span class="line">    &#125;</span><br><span class="line">    //!注意，characteristic.value的类型是NSData，具体开发时，会根据外设协议制定的方式去解析数据</span><br><span class="line">    if (self.didUpdateValueForCharacteristicBlock) &#123;</span><br><span class="line">        self.didUpdateValueForCharacteristicBlock(peripheral, characteristic, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-获取Characteristics的Descriptor"><a href="#2-4-获取Characteristics的Descriptor" class="headerlink" title="2.4 获取Characteristics的Descriptor"></a>2.4 获取Characteristics的Descriptor</h4><p>通过<code>[peripheral discoverDescriptorsForCharacteristic:characteristic];</code>，扫描每个Characteristics的Descriptor。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/** 发现Characteristics的Descriptors */</span><br><span class="line">- (void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error &#123;</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt;error Discovered DescriptorsForCharacteristic for %@ with error: %@&quot;, characteristic.UUID, [error localizedDescription]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.discoverDescriptorsForCharacteristicBlock) &#123;</span><br><span class="line">        self.discoverDescriptorsForCharacteristicBlock(peripheral, characteristic, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-断开连接"><a href="#3-断开连接" class="headerlink" title="3 断开连接"></a>3 断开连接</h3><p>通过<code>[_centralManager cancelPeripheralConnection:peripheral];</code>，断开连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/** 停止扫描并断开连接 */</span><br><span class="line">-(void)disconnectPeripheral:(CBCentralManager *)centralManager</span><br><span class="line">                 peripheral:(CBPeripheral *)peripheral&#123;</span><br><span class="line">    //停止扫描</span><br><span class="line">    [centralManager stopScan];</span><br><span class="line">    //断开连接</span><br><span class="line">    [centralManager cancelPeripheralConnection:peripheral];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中心设备的开发是需要配合外设来进行的，一般会有硬件工程师或嵌入式工程师给出通信协议，根据协议来对项目的各种需求进行操作。<br>若想深入的了解蓝牙开发，不下苦功是不行的。</p><p>最后附上我的<a href="https://github.com/iMHaoyu/HYBluetoothManager" target="_blank" rel="noopener">Demo</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;时隔几个月再次拾起了我的博客（猛然发现我是有博客的人啊….），当然，最近还是挺累的，经过家里之前有些事情，回来后就格外的累，其次就是最近都没有什么可以记录的事情。当然，我没有把博客当作日记来记录，而是当作一个技术类来记录的，所以没有那么勤快。（此处只是借口…还是没有养成写博客的习惯）&lt;/p&gt;
&lt;p&gt;废话不多说，最近学习了iOS的蓝牙模块，然后这里就根据&lt;a href=&quot;https://github.com/iMHaoyu/HYBluetoothManager&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的学习代码&lt;/a&gt;来稍微总结一下iOS中心模式的应用场景。（PS:代码只是用来理解流程的，具体的可以看看大神封装的这个蓝牙库&lt;a href=&quot;https://github.com/coolnameismy/BabyBluetooth&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BabyBluetooth&lt;/a&gt;）中心模式：主设备是手机，用手机扫描连接外设，发现外设服务和属性，操作服务和属性的应用。这里的外设就是蓝牙设备，比如智能手环之类的东西。一般外设会由硬件工程师开发好，并定义好设备提供的服务，每个服务对于的特征，每个特征的属性（只读，只写，通知等等）。&lt;/p&gt;
&lt;p&gt;本文例子的业务场景，就是用一手机app去读写蓝牙设备。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;蓝牙基础知识&quot;&gt;&lt;a href=&quot;#蓝牙基础知识&quot; class=&quot;headerlink&quot; title=&quot;蓝牙基础知识&quot;&gt;&lt;/a&gt;蓝牙基础知识&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;CoreBluetooth框架的核心其实是两个东西，peripheral和central, 可以理解成外设和中心。对应他们分别有一组相关的API和类。&lt;/p&gt;
&lt;p&gt;每个设备都会有一些服务，每个服务里面都会有一些特征，特征就是具体键值对，提供数据的地方。每个特征属性分为这么几种：读，写，通知这么几种方式。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://xuhaoyucn.com/categories/iOS/"/>
    
    
      <category term="iOS蓝牙开发" scheme="https://xuhaoyucn.com/tags/iOS%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>自定义转场动画</title>
    <link href="https://xuhaoyucn.com/2018/10/10/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    <id>https://xuhaoyucn.com/2018/10/10/自定义转场动画/</id>
    <published>2018-10-10T08:11:58.000Z</published>
    <updated>2018-12-20T02:33:04.129Z</updated>
    
    <content type="html"><![CDATA[<p>之前看了onevcat大神的这篇博客：<a href="https://onevcat.com/2013/10/vc-transition-in-ios7/" target="_blank" rel="noopener">WWDC 2013 Session笔记 - iOS7中的ViewController切换</a>，很有兴趣，就针对iOS的转场动画进行了学习。其实在之前也遇到过此类的文章，一直以为要花较多的时间研究，所以就搁置了很久。一直等到我准备写一个iOS的框架才突然想到要学习以下，然后把转场动画放入我的框架中，就这样就开始了。</p><p>其实关于这方面的文章网络上也已经很多了，作为新手，我想通过这篇文章把自己的学习心得记录一下，方便加深印象和以后的回顾。这是也我第一次写技术文章，不好之处和错误的地方请谅解，也欢迎大神给予指点。废话不多说，开始吧。</p><p>以下的所有相关的API都定义在UIKit的  UIViewControllerTransitioning.h  中了，为了便于比较和记忆，我把比较关键的API都列在下面。</p><p>关于自定义转场就离不开这几个Protocol：</p><ul><li><strong>UIViewControllerContextTransitioning</strong></li><li><strong>UIViewControllerAnimatedTransitioning</strong></li><li><strong>UIViewControllerInteractiveTransitioning</strong></li><li><strong>UIViewControllerTransitioningDelegate</strong></li><li><strong>UINavigationControllerDelegate</strong></li><li><strong>UITabBarControllerDelegate</strong></li></ul><p>我之前乍一看这么多协议都乱了，其实很简单，我们可以将其分为三类：</p><a id="more"></a><p>1.描述ViewController转场的：</p><ul><li><strong>UIViewControllerTransitioningDelegate</strong></li><li><strong>UINavigationControllerDelegate</strong></li><li><strong>UITabBarControllerDelegate</strong></li></ul><p>2.定义动画内容的</p><ul><li><strong>UIViewControllerAnimatedTransitioning</strong></li><li><strong>UIViewControllerInteractiveTransitioning</strong></li></ul><p>3.表示转场动画上下文的</p><ul><li><strong>UIViewControllerContextTransitioning</strong></li></ul><p>首先，实现自定义ViewController的转场动画首先就要找到 <strong>Delegate</strong>。ViewController的切换可以有三种：<strong>UITabBarController</strong> -标签控制器的控制器切换，<strong>UINavigationController</strong>-导航控制器push和pop，<strong>ViewController</strong>-模态的present和dismiss（present modal ViewController），这三种方式都遵循这不同的协议来实现，我们来分别看下：</p><blockquote><ul><li>UIViewControllerTransitioningDelegate 自定义模态转场动画时使用。<br>设置UIViewController的属性 <strong>transitioningDelegate</strong> 。  @property (nullable, nonatomic, weak) id <uiviewcontrollertransitioningdelegate> transitioningDelegate</uiviewcontrollertransitioningdelegate></li></ul><ul><li>UINavigationControllerDelegate 自定义navigation转场动画时使用。<br>设置UINavigationController的属性<strong>delegate</strong>。@property(nullable, nonatomic, weak) id<uinavigationcontrollerdelegate> delegate</uinavigationcontrollerdelegate></li></ul><ul><li>UITabBarControllerDelegate 自定义tab转场动画时使用。<br>设置UITabBarController的属性<strong>delegate</strong>。@property(nullable, nonatomic,weak) id<uitabbarcontrollerdelegate> delegate</uitabbarcontrollerdelegate></li></ul></blockquote><p>其实这三个协议基本上是一样的，只是应用的场景不同而已。下面我是以<strong>模态</strong>为例写了一个Demo，我将开始介绍实现的步骤。</p><p>在开始之前，我们需要了解<strong>UIViewControllerContextTransitioning</strong>, <strong>UIViewControllerAnimatedTransitioning</strong> 和<strong>UIViewControllerTransitioningDelegate</strong>，这三个协议下的重要API：</p><p><br></p><p><font color="#0099ff" size="3" face="黑体">@protocol UIViewControllerContextTransitioning</font><br>这个接口用来提供切换上下文给开发者使用，包含了从哪个VC到哪个VC等各类信息，一般不需要开发者自己实现。具体来说，iOS7时自定义切换目的之一就是切换相关代码解耦，在进行VC切换时，做切换效果实现的时候必须需要切换前后VC的一些信息，系统在新加入的API的比较的地方都会提供一个实现了该接口的对象，以供我们使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(UIView *)containerView; //VC切换所发生的view容器，开发者应该将切出的view移除，将切入的view加入到该view容器中。</span><br><span class="line">-(UIViewController *)viewControllerForKey:(NSString *)key; //提供一个key，返回对应的VC。现在的SDK中key的选择只有UITransitionContextFromViewControllerKey和UITransitionContextToViewControllerKey两种，分别表示将要切出和切入的VC。</span><br><span class="line">-(CGRect)initialFrameForViewController:(UIViewController *)vc; //某个VC的初始位置，可以用来做动画的计算。</span><br><span class="line">-(CGRect)finalFrameForViewController:(UIViewController *)vc; //与上面的方法对应，得到切换结束时某个VC应在的frame。</span><br><span class="line">-(void)completeTransition:(BOOL)didComplete; //向这个context报告切换已经完成。</span><br></pre></td></tr></table></figure><p><font color="#0099ff" size="3" face="黑体">@protocol UIViewControllerAnimatedTransitioning</font><br>这个接口负责切换的具体内容，也即“切换中应该发生什么”。开发者在做自定义切换效果时大部分代码会是用来实现这个接口。它只有两个方法需要我们实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-(NSTimeInterval)transitionDuration:(id &lt; UIViewControllerContextTransitioning &gt;)transitionContext; //系统给出一个切换上下文，我们根据上下文环境返回这个切换所需要的花费时间（一般就返回动画的时间就好了，SDK会用这个时间来在百分比驱动的切换中进行帧的计算，后面再详细展开）。</span><br><span class="line">-(void)animateTransition:(id &lt; UIViewControllerContextTransitioning &gt;)transitionContext; //在进行切换的时候将调用该方法，我们对于切换时的UIView的设置和动画都在这个方法中完成。</span><br></pre></td></tr></table></figure><p><font color="#0099ff" size="3" face="黑体">@protocol UIViewControllerTransitioningDelegate</font><br>这个接口的作用比较简单单一，在需要VC切换的时候系统会像实现了这个接口的对象询问是否需要使用自定义的切换效果。这个接口共有四个类似的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(id&lt; UIViewControllerAnimatedTransitioning &gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source; //我这里是返回一个过渡动画管理对象 UIViewControllerAnimatedTransitioning - 在模态弹出调用的</span><br><span class="line">-(id&lt; UIViewControllerAnimatedTransitioning &gt;)animationControllerForDismissedController:(UIViewController *)dismissed;//我这里是返回一个过渡动画管理对象 UIViewControllerAnimatedTransitioning - 在模态弹出后Dismiss调用的</span><br><span class="line">-(id&lt; UIViewControllerInteractiveTransitioning &gt;)interactionControllerForPresentation:(id &lt; UIViewControllerAnimatedTransitioning &gt;)animator; //返回转换的手势交互管理对象 -  在模态弹出调用的</span><br><span class="line">-(id&lt; UIViewControllerInteractiveTransitioning &gt;)interactionControllerForDismissal:(id &lt; UIViewControllerAnimatedTransitioning &gt;)animator; //返回转换的手势交互管理对象 -  在模态弹出后Dismiss调用的</span><br></pre></td></tr></table></figure><p>前两个方法是针对动画切换的，我们需要分别在呈现VC和解散VC时，给出一个实现了UIViewControllerAnimatedTransitioning接口的对象（其中包含切换时长和如何切换）。后两个方法涉及交互式切换。</p><p><br><br>下面贴出我的代码，正式开始：</p><p>首先根据 <strong>UIViewControllerTransitioningDelegate</strong> 中的上面介绍的四个方法，分别新建四个对象（我这边没有新建模态弹出的手势交互管理对象）</p><ul><li>HYPresentAnimation - 主要提供转场开始的过渡动画</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">//HYPresentAnimation.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface HYPresentAnimation : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//HYPresentAnimation.m</span><br><span class="line">#import &quot;HYPresentAnimation.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation HYPresentAnimation</span><br><span class="line"></span><br><span class="line">- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123;</span><br><span class="line">    return 0.5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123;</span><br><span class="line">    //通过viewControllerForKey取出转场前后的两个控制器，这里toVC就是vc1、fromVC就是vc2</span><br><span class="line">    UIViewController *toVC   = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];</span><br><span class="line">    UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];</span><br><span class="line">    //snapshotViewAfterScreenUpdates可以对某个视图截图，我们采用对这个截图做动画代替直接对vc1做动画，因为在手势过渡中直接使用vc1动画会和手势有冲突， 如果不需要实现手势的话，就可以不是用截图视图了，大家可以自行尝试一下</span><br><span class="line">    UIView *tempView = [fromVC.view snapshotViewAfterScreenUpdates:NO];</span><br><span class="line">    tempView.frame   = fromVC.view.frame;</span><br><span class="line">    tempView.layer.masksToBounds = YES;</span><br><span class="line">    //因为对截图做动画，vc1就可以隐藏了</span><br><span class="line">    fromVC.view.hidden = YES;</span><br><span class="line">    //这里有个重要的概念containerView，如果要对视图做转场动画，视图就必须要加入containerView中才能进行，可以理解containerView管理着所有做转场动画的视图</span><br><span class="line">    UIView *containerView = [transitionContext containerView];</span><br><span class="line">    //将截图视图和vc2的view都加入ContainerView中</span><br><span class="line">    [containerView addSubview:tempView];</span><br><span class="line">    [containerView addSubview:toVC.view];</span><br><span class="line"></span><br><span class="line">    //顶部间隔</span><br><span class="line">    CGFloat space = 80;</span><br><span class="line">    //设置vc2的frame，因为这里vc2present出来不是全屏，且初始的时候在底部，如果不设置frame的话默认就是整个屏幕咯，这里containerView的frame就是整个屏幕</span><br><span class="line">    toVC.view.frame = CGRectMake(0, containerView.frame.size.height, containerView.frame.size.width, containerView.frame.size.height-space);</span><br><span class="line">    //开始动画吧，使用产生弹簧效果的动画API</span><br><span class="line">    [UIView animateWithDuration:[self transitionDuration:transitionContext] delay:0 usingSpringWithDamping:.85 initialSpringVelocity:1.0 / 0.55 options:0 animations:^&#123;</span><br><span class="line">        //首先我们让vc2向上移动</span><br><span class="line">        toVC.view.transform = CGAffineTransformMakeTranslation(0, -(containerView.frame.size.height-space));</span><br><span class="line">        //然后让截图视图缩小一点即可</span><br><span class="line">        tempView.transform = CGAffineTransformMakeScale(0.96, 0.96);</span><br><span class="line">        tempView.layer.cornerRadius = 8;</span><br><span class="line">        //改变状态栏颜色</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        //使用如下代码标记整个转场过程是否正常完成[transitionContext transitionWasCancelled]代表手势是否取消了，如果取消了就传NO表示转场失败，反之亦然，如果不用手势present的话直接传YES也是可以的，但是无论如何我们都必须标记转场的状态，系统才知道处理转场后的操作，否者认为你一直还在转场中，会出现无法交互的情况，切记！</span><br><span class="line">        [transitionContext completeTransition:![transitionContext transitionWasCancelled]];</span><br><span class="line">        //转场失败后的处理</span><br><span class="line">        if ([transitionContext transitionWasCancelled]) &#123;</span><br><span class="line">            //失败后，我们要把vc1显示出来</span><br><span class="line">            fromVC.view.hidden = NO;</span><br><span class="line">            //然后移除截图视图，因为下次触发present会重新截图</span><br><span class="line">            [tempView removeFromSuperview];</span><br><span class="line">            [transitionContext completeTransition:NO];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>HYDismissAnimation - Dismiss时的过渡动画</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//HYDismissAnimation.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface HYDismissAnimation : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//HYDismissAnimation.m</span><br><span class="line">#import &quot;HYDismissAnimation.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation HYDismissAnimation</span><br><span class="line">- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123;</span><br><span class="line">    return 0.5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123;</span><br><span class="line">    //注意在dismiss的时候fromVC就是vc2了，toVC才是VC1了，注意这个关系</span><br><span class="line">    UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];</span><br><span class="line">    UIViewController *toVC   = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];</span><br><span class="line">    //参照present动画的逻辑，present成功后，containerView的最后一个子视图就是截图视图，我们将其取出准备动画</span><br><span class="line">    UIView *tempView = [transitionContext containerView].subviews[0];</span><br><span class="line">    //动画吧</span><br><span class="line">    [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^&#123;</span><br><span class="line">        //因为present的时候都是使用的transform，这里的动画只需要将transform恢复就可以了</span><br><span class="line">        fromVC.view.transform = CGAffineTransformIdentity;</span><br><span class="line">        tempView.transform    = CGAffineTransformIdentity;</span><br><span class="line">        tempView.layer.cornerRadius = 0;</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">        if ([transitionContext transitionWasCancelled]) &#123;</span><br><span class="line">            //失败了标记失败</span><br><span class="line">            [transitionContext completeTransition:NO];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //如果成功了，我们需要标记成功，同时让vc1显示出来，然后移除截图视图，</span><br><span class="line">            [transitionContext completeTransition:YES];</span><br><span class="line">            toVC.view.hidden = NO;</span><br><span class="line">            [tempView removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>HYInteractiveTransition - Dismiss手势交互管理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//HYInteractiveTransition.h</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface HYInteractiveTransition : UIPercentDrivenInteractiveTransition</span><br><span class="line">//是否是正在交互中</span><br><span class="line">@property (nonatomic, assign) BOOL interacting;</span><br><span class="line"></span><br><span class="line">- (void)wireToViewController:(UIViewController*)viewController;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//HYInteractiveTransition.m</span><br><span class="line">#import &quot;HYInteractiveTransition.h&quot;</span><br><span class="line"></span><br><span class="line">@interface HYInteractiveTransition()</span><br><span class="line">@property (nonatomic, assign) BOOL shouldComplete;</span><br><span class="line">@property (nonatomic, strong) UIViewController *presentingVC;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation HYInteractiveTransition</span><br><span class="line"></span><br><span class="line">- (void)wireToViewController:(UIViewController*)viewController &#123;</span><br><span class="line">    self.presentingVC = viewController;</span><br><span class="line">    [self prepareGestureRecognizerInView:viewController.view];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)prepareGestureRecognizerInView:(UIView*)view &#123;</span><br><span class="line">    UIPanGestureRecognizer *gesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handleGesture:)];</span><br><span class="line">    [view addGestureRecognizer:gesture];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)handleGesture:(UIPanGestureRecognizer *)gestureRecognizer &#123;</span><br><span class="line">    CGPoint translation = [gestureRecognizer translationInView:gestureRecognizer.view];</span><br><span class="line">    switch (gestureRecognizer.state) &#123;</span><br><span class="line">        case UIGestureRecognizerStateBegan:</span><br><span class="line">            //1.标记交互标志。 在委托中提供时使用。</span><br><span class="line">            self.interacting = YES;</span><br><span class="line">            [self.presentingVC dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">            break;</span><br><span class="line">        case UIGestureRecognizerStateChanged:</span><br><span class="line">        &#123;</span><br><span class="line">            // 2. 计算手势的百分比</span><br><span class="line">            CGFloat fraction = translation.y / gestureRecognizer.view.frame.size.height;;</span><br><span class="line">            //限制在0和1之间</span><br><span class="line">            fraction = fminf(fmaxf(fraction, 0.0), 1.0);</span><br><span class="line">            self.shouldComplete = (fraction &gt; 0.3);</span><br><span class="line"></span><br><span class="line">            [self updateInteractiveTransition:fraction];</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line">        case UIGestureRecognizerStateEnded:</span><br><span class="line">        case UIGestureRecognizerStateCancelled:</span><br><span class="line">        &#123;</span><br><span class="line">            //3.手势交互结束。检查转换是否应该发生</span><br><span class="line">            self.interacting = NO;</span><br><span class="line">            if (!self.shouldComplete || gestureRecognizer.state == UIGestureRecognizerStateCancelled) &#123;</span><br><span class="line">                [self cancelInteractiveTransition];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                [self finishInteractiveTransition];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>然后在VC1中实现下面的方法（这里就姑且叫VC1吧，逻辑关系是：从VC1跳转到VC2):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source &#123;</span><br><span class="line">    return self.presentAnimation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed &#123;</span><br><span class="line">    return self.dismissAnimation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForPresentation:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator &#123;</span><br><span class="line">//</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator &#123;</span><br><span class="line">    return self.transitionController.interacting ? self.transitionController : nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<strong>self.presentAnimation</strong>、<strong>self.dismissAnimation</strong><br>、<strong>self.transitionController</strong>是我定义的属性，因为我没有实现从VC1弹出VC2的手势交互，所以我把这个方法注释掉了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) HYPresentAnimation *presentAnimation;</span><br><span class="line">@property (nonatomic, strong) HYDismissAnimation *dismissAnimation;</span><br><span class="line">@property (nonatomic, strong) HYInteractiveTransition *transitionController;</span><br></pre></td></tr></table></figure><p>最后别忘了实现<strong>transitioningDelegate</strong>，要想Dismiss的时候就可以直接手指下滑就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)btnClicked:(UIButton *)sender &#123;</span><br><span class="line">  HYSecondVC *tempVC = [[HYSecondVC alloc]init];</span><br><span class="line">  tempVC.transitioningDelegate = self;</span><br><span class="line">  [self.transitionController wireToViewController:tempVC];</span><br><span class="line">  [self presentViewController:tempVC animated:YES completion:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我已经把我的<a href="https://github.com/iMHaoyu/HYAnimatedTransitions" target="_blank" rel="noopener">Demo</a>放在了Github上，有需要的可以看看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前看了onevcat大神的这篇博客：&lt;a href=&quot;https://onevcat.com/2013/10/vc-transition-in-ios7/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WWDC 2013 Session笔记 - iOS7中的ViewController切换&lt;/a&gt;，很有兴趣，就针对iOS的转场动画进行了学习。其实在之前也遇到过此类的文章，一直以为要花较多的时间研究，所以就搁置了很久。一直等到我准备写一个iOS的框架才突然想到要学习以下，然后把转场动画放入我的框架中，就这样就开始了。&lt;/p&gt;
&lt;p&gt;其实关于这方面的文章网络上也已经很多了，作为新手，我想通过这篇文章把自己的学习心得记录一下，方便加深印象和以后的回顾。这是也我第一次写技术文章，不好之处和错误的地方请谅解，也欢迎大神给予指点。废话不多说，开始吧。&lt;/p&gt;
&lt;p&gt;以下的所有相关的API都定义在UIKit的  UIViewControllerTransitioning.h  中了，为了便于比较和记忆，我把比较关键的API都列在下面。&lt;/p&gt;
&lt;p&gt;关于自定义转场就离不开这几个Protocol：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;UIViewControllerContextTransitioning&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UIViewControllerAnimatedTransitioning&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UIViewControllerInteractiveTransitioning&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UIViewControllerTransitioningDelegate&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UINavigationControllerDelegate&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UITabBarControllerDelegate&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我之前乍一看这么多协议都乱了，其实很简单，我们可以将其分为三类：&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://xuhaoyucn.com/categories/iOS/"/>
    
    
      <category term="模态弹出的转场动画" scheme="https://xuhaoyucn.com/tags/%E6%A8%A1%E6%80%81%E5%BC%B9%E5%87%BA%E7%9A%84%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>第一篇</title>
    <link href="https://xuhaoyucn.com/2018/09/29/%E5%BC%80%E7%AF%87%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    <id>https://xuhaoyucn.com/2018/09/29/开篇第一篇/</id>
    <published>2018-09-29T06:02:31.000Z</published>
    <updated>2018-09-29T06:55:48.914Z</updated>
    
    <content type="html"><![CDATA[<p>在某种机缘巧合之下，接触了个人博客 Octopress，然后就很感兴趣，就想的搭建属于自己的个人博客，以此来激励自己更努力的学习。</p><p>然后我就查找了好多关于 Octopress 的文章，不过后来看到了 Hexo ，发现 Hexo 的博客主题比 Octopress 多很多也很好看于是上网找了Hexo博客的搭建方法。 于是我的第一个个人博客就这样出现了，当然期间也花费了很多时间和精力，每天提前三个多小时到公司连续弄了三四天。还好，结果还是让人很满意的！</p><a id="more"></a><blockquote><p>ps：本人是在公司工作不是那么忙的时候弄的，如果你们公司的事情很多，我建议各位还是有空的时候在弄吧。毕竟有些东西还是要深入的了解一下的。</p></blockquote><p>在写这篇博客的时候有想过把我学习搭建博客的方法分享给大家，但是发现关于 Hexo+Github 搭建博客的方法有很多，所以我也就没有写下来。<br>不过我还是把我参考的方法链接分享给大家吧：</p><blockquote><p>搭建方法：</p><ul><li><a href="https://blog.csdn.net/qq_34290780/article/details/78230706" target="_blank" rel="noopener">https://blog.csdn.net/qq_34290780/article/details/78230706</a></li></ul><p>我用的主题是： - “pure”</p><ul><li><a href="https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md" target="_blank" rel="noopener">https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md</a></li></ul><p>可以根据以上的方法搭建自己的博客主题</p></blockquote><p>现在写个博客感觉好像又回到了高中写作文的时候，本来就偏科文采不是很好，所有就先写到这吧…</p><p>对了，我以后会把我的学习成果和总计、学到的新的技术、封装的框架或控件的思路都写在博客里面，会不定时的更新出来，希望有什么不足的可以指出来，有什么需要指点的也可以联系我，我会尽力帮助你。欢迎各位不吝赐教，共同学习，一起成长！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在某种机缘巧合之下，接触了个人博客 Octopress，然后就很感兴趣，就想的搭建属于自己的个人博客，以此来激励自己更努力的学习。&lt;/p&gt;
&lt;p&gt;然后我就查找了好多关于 Octopress 的文章，不过后来看到了 Hexo ，发现 Hexo 的博客主题比 Octopress 多很多也很好看于是上网找了Hexo博客的搭建方法。 于是我的第一个个人博客就这样出现了，当然期间也花费了很多时间和精力，每天提前三个多小时到公司连续弄了三四天。还好，结果还是让人很满意的！&lt;/p&gt;
    
    </summary>
    
      <category term="个人总结" scheme="https://xuhaoyucn.com/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="感悟" scheme="https://xuhaoyucn.com/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
</feed>
