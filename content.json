{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"xuhaoyu","url":"https://xuhaoyucn.com"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-09-29T02:23:58.253Z","updated":"2018-09-29T01:36:27.476Z","comments":false,"path":"/404.html","permalink":"https://xuhaoyucn.com//404.html","excerpt":"","text":""},{"title":"关于","date":"2018-09-29T02:54:57.659Z","updated":"2018-09-29T02:54:57.649Z","comments":false,"path":"about/index.html","permalink":"https://xuhaoyucn.com/about/index.html","excerpt":"","text":"个人详细介绍 本人是一位iOS开发的小菜鸟，希望能够在以后的时间了努力学习，取得进步！！在此记录我的学习笔记，仅此来留下我的成长足迹……"},{"title":"书单","date":"2018-09-29T02:23:58.281Z","updated":"2018-09-29T01:36:27.477Z","comments":false,"path":"books/index.html","permalink":"https://xuhaoyucn.com/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-09-29T02:27:10.082Z","updated":"2018-09-29T01:36:27.477Z","comments":true,"path":"links/index.html","permalink":"https://xuhaoyucn.com/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-09-29T02:23:58.294Z","updated":"2018-09-29T01:36:27.477Z","comments":false,"path":"categories/index.html","permalink":"https://xuhaoyucn.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-09-29T02:23:58.334Z","updated":"2018-09-29T01:36:27.477Z","comments":false,"path":"tags/index.html","permalink":"https://xuhaoyucn.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-09-29T02:24:44.535Z","updated":"2018-09-29T01:36:27.477Z","comments":false,"path":"repository/index.html","permalink":"https://xuhaoyucn.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"自定义转场动画","slug":"自定义转场动画","date":"2018-10-10T08:11:58.000Z","updated":"2018-10-10T22:25:47.016Z","comments":true,"path":"2018/10/10/自定义转场动画/","link":"","permalink":"https://xuhaoyucn.com/2018/10/10/自定义转场动画/","excerpt":"之前看了onevcat大神的这篇博客：WWDC 2013 Session笔记 - iOS7中的ViewController切换，\b很有兴趣，就针对iOS的转场动画\b进行了\b学习。其实在之前也遇到过此类的文章，一直以为要花较\b多的时间研究，所以就搁置了很久。一直等到我准备写一个iOS的框架才突然想到要学习以下，然后把转场动画放入我的框架中，就这样就开始了。 其实关于这方面的文章网络上也已经很多了，作为新手，我想通过这篇文章把自己的学习心得记录一下，方便加深印象和以后的回顾。这是也我第一次写技术文章，不好之处和错误的地方请谅解，也欢迎大神给予指点。废话不多说，开始吧。 \b\b\b\b以下的所有相关的API都定义在UIKit的 UIViewControllerTransitioning.h 中了，为了便于比较和记忆，我把比较关键的API都列在下面。 关于自定义转场就离不开这几个Protocol： UIViewControllerContextTransitioning UIViewControllerAnimatedTransitioning UIViewControllerInteractiveTransitioning UIViewControllerTransitioningDelegate UINavigationControllerDelegate UITabBarControllerDelegate 我之前乍一看这么多协议都乱了，其实很简单，我们可以将其分为三类：","text":"之前看了onevcat大神的这篇博客：WWDC 2013 Session笔记 - iOS7中的ViewController切换，\b很有兴趣，就针对iOS的转场动画\b进行了\b学习。其实在之前也遇到过此类的文章，一直以为要花较\b多的时间研究，所以就搁置了很久。一直等到我准备写一个iOS的框架才突然想到要学习以下，然后把转场动画放入我的框架中，就这样就开始了。 其实关于这方面的文章网络上也已经很多了，作为新手，我想通过这篇文章把自己的学习心得记录一下，方便加深印象和以后的回顾。这是也我第一次写技术文章，不好之处和错误的地方请谅解，也欢迎大神给予指点。废话不多说，开始吧。 \b\b\b\b以下的所有相关的API都定义在UIKit的 UIViewControllerTransitioning.h 中了，为了便于比较和记忆，我把比较关键的API都列在下面。 关于自定义转场就离不开这几个Protocol： UIViewControllerContextTransitioning UIViewControllerAnimatedTransitioning UIViewControllerInteractiveTransitioning UIViewControllerTransitioningDelegate UINavigationControllerDelegate UITabBarControllerDelegate 我之前乍一看这么多协议都乱了，其实很简单，我们可以将其分为三类： 1.描述ViewController转场的： UIViewControllerTransitioningDelegate UINavigationControllerDelegate UITabBarControllerDelegate 2.定义动画内容的 UIViewControllerAnimatedTransitioning UIViewControllerInteractiveTransitioning 3.表示转场动画上下文的\b UIViewControllerContextTransitioning 首先，实现自定义ViewController的转场动画首先就要找到 Delegate。ViewController的切换可以有三种：UITabBarController -标签控制器的控制器切换，UINavigationController-导航控制器push和pop，ViewController-模态的present和dismiss（present modal ViewController），这三种方式都遵循这不同的协议来实现，我们来分别看下： UIViewControllerTransitioningDelegate 自定义模态转场动画时使用。设置UIViewController的属性 transitioningDelegate 。 @property (nullable, nonatomic, weak) id transitioningDelegate UINavigationControllerDelegate 自定义navigation转场动画时使用。设置UINavigationController的属性delegate。@property(nullable, nonatomic, weak) id delegate UITabBarControllerDelegate 自定义tab转场动画时使用。设置UITabBarController的属性delegate。@property(nullable, nonatomic,weak) id delegate 其实这三个协议基本上是一样的，只是应用的场景不同而已。下面我是以模态为例写了一个Demo，我将开始介绍实现的步骤。 在开始之前，我们需要了解UIViewControllerContextTransitioning, UIViewControllerAnimatedTransitioning 和UIViewControllerTransitioningDelegate，这三个协议下的重要API： @protocol UIViewControllerContextTransitioning这个接口用来提供切换上下文给开发者使用，包含了从哪个VC到哪个VC等各类信息，一般不需要开发者自己实现。具体来说，iOS7时自定义切换目的之一就是切换相关代码解耦，在进行VC切换时，做切换效果实现的时候必须需要切换前后VC的一些信息，系统在新加入的API的比较的地方都会提供一个实现了该接口的对象，以供我们使用。 12345-(UIView *)containerView; //VC切换所发生的view容器，开发者应该将切出的view移除，将切入的view加入到该view容器中。-(UIViewController *)viewControllerForKey:(NSString *)key; //提供一个key，返回对应的VC。现在的SDK中key的选择只有UITransitionContextFromViewControllerKey和UITransitionContextToViewControllerKey两种，分别表示将要切出和切入的VC。-(CGRect)initialFrameForViewController:(UIViewController *)vc; //某个VC的初始位置，可以用来做动画的计算。-(CGRect)finalFrameForViewController:(UIViewController *)vc; //与上面的方法对应，得到切换结束时某个VC应在的frame。-(void)completeTransition:(BOOL)didComplete; //向这个context报告切换已经完成。 @protocol UIViewControllerAnimatedTransitioning这个接口负责切换的具体内容，也即“切换中应该发生什么”。开发者在做自定义切换效果时大部分代码会是用来实现这个接口。它只有两个方法需要我们实现： 12-(NSTimeInterval)transitionDuration:(id &lt; UIViewControllerContextTransitioning &gt;)transitionContext; //系统给出一个切换上下文，我们根据上下文环境返回这个切换所需要的花费时间（一般就返回动画的时间就好了，SDK会用这个时间来在百分比驱动的切换中进行帧的计算，后面再详细展开）。-(void)animateTransition:(id &lt; UIViewControllerContextTransitioning &gt;)transitionContext; //在进行切换的时候将调用该方法，我们对于切换时的UIView的设置和动画都在这个方法中完成。 @protocol UIViewControllerTransitioningDelegate这个接口的作用比较简单单一，在需要VC切换的时候系统会像实现了这个接口的对象询问是否需要使用自定义的切换效果。这个接口共有四个类似的方法： 1234-(id&lt; UIViewControllerAnimatedTransitioning &gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source; //我这里是返回一个过渡动画管理对象 UIViewControllerAnimatedTransitioning - 在模态弹出调用的-(id&lt; UIViewControllerAnimatedTransitioning &gt;)animationControllerForDismissedController:(UIViewController *)dismissed;//我这里是返回一个过渡动画管理对象 UIViewControllerAnimatedTransitioning - 在模态弹出后Dismiss调用的-(id&lt; UIViewControllerInteractiveTransitioning &gt;)interactionControllerForPresentation:(id &lt; UIViewControllerAnimatedTransitioning &gt;)animator; //返回转换的手势交互管理对象 - 在模态弹出调用的-(id&lt; UIViewControllerInteractiveTransitioning &gt;)interactionControllerForDismissal:(id &lt; UIViewControllerAnimatedTransitioning &gt;)animator; //返回转换的手势交互管理对象 - 在模态弹出后Dismiss调用的 前两个方法是针对动画切换的，我们需要分别在呈现VC和解散VC时，给出一个实现了UIViewControllerAnimatedTransitioning接口的对象（其中包含切换时长和如何切换）。后两个方法涉及交互式切换。 下面贴出我的代码，正式开始： 首先根据 UIViewControllerTransitioningDelegate 中的上面介绍的四个方法，分别新建四个对象（\b我这边没有新建模态弹出的手势交互管理对象） HYPresentAnimation - 主要提供转场开始的过渡动画 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//HYPresentAnimation.h#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;@interface HYPresentAnimation : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;@end//HYPresentAnimation.m#import &quot;HYPresentAnimation.h&quot;@implementation HYPresentAnimation- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; return 0.5;&#125;- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; //通过viewControllerForKey取出转场前后的两个控制器，这里toVC就是vc1、fromVC就是vc2 UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; //snapshotViewAfterScreenUpdates可以对某个视图截图，我们采用对这个截图做动画代替直接对vc1做动画，因为在手势过渡中直接使用vc1动画会和手势有冲突， 如果不需要实现手势的话，就可以不是用截图视图了，大家可以自行尝试一下 UIView *tempView = [fromVC.view snapshotViewAfterScreenUpdates:NO]; tempView.frame = fromVC.view.frame; tempView.layer.masksToBounds = YES; //因为对截图做动画，vc1就可以隐藏了 fromVC.view.hidden = YES; //这里有个重要的概念containerView，如果要对视图做转场动画，视图就必须要加入containerView中才能进行，可以理解containerView管理着所有做转场动画的视图 UIView *containerView = [transitionContext containerView]; //将截图视图和vc2的view都加入ContainerView中 [containerView addSubview:tempView]; [containerView addSubview:toVC.view]; //顶部间隔 CGFloat space = 80; //设置vc2的frame，因为这里vc2present出来不是全屏，且初始的时候在底部，如果不设置frame的话默认就是整个屏幕咯，这里containerView的frame就是整个屏幕 toVC.view.frame = CGRectMake(0, containerView.frame.size.height, containerView.frame.size.width, containerView.frame.size.height-space); //开始动画吧，使用产生弹簧效果的动画API [UIView animateWithDuration:[self transitionDuration:transitionContext] delay:0 usingSpringWithDamping:.85 initialSpringVelocity:1.0 / 0.55 options:0 animations:^&#123; //首先我们让vc2向上移动 toVC.view.transform = CGAffineTransformMakeTranslation(0, -(containerView.frame.size.height-space)); //然后让截图视图缩小一点即可 tempView.transform = CGAffineTransformMakeScale(0.96, 0.96); tempView.layer.cornerRadius = 8; //改变状态栏颜色 &#125; completion:^(BOOL finished) &#123; //使用如下代码标记整个转场过程是否正常完成[transitionContext transitionWasCancelled]代表手势是否取消了，如果取消了就传NO表示转场失败，反之亦然，如果不用手势present的话直接传YES也是可以的，但是无论如何我们都必须标记转场的状态，系统才知道处理转场后的操作，否者认为你一直还在转场中，会出现无法交互的情况，切记！ [transitionContext completeTransition:![transitionContext transitionWasCancelled]]; //转场失败后的处理 if ([transitionContext transitionWasCancelled]) &#123; //失败后，我们要把vc1显示出来 fromVC.view.hidden = NO; //然后移除截图视图，因为下次触发present会重新截图 [tempView removeFromSuperview]; [transitionContext completeTransition:NO]; &#125; &#125;];&#125;@end HYDismissAnimation - \bDismiss时的\b过渡动画 12345678910111213141516171819202122232425262728293031323334353637383940414243//HYDismissAnimation.h#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;@interface HYDismissAnimation : NSObject &lt;UIViewControllerAnimatedTransitioning&gt;@end//HYDismissAnimation.m#import &quot;HYDismissAnimation.h&quot;@implementation HYDismissAnimation- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; return 0.5;&#125;- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext &#123; //注意在dismiss的时候fromVC就是vc2了，toVC才是VC1了，注意这个关系 UIViewController *fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; UIViewController *toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; //参照present动画的逻辑，present成功后，containerView的最后一个子视图就是截图视图，我们将其取出准备动画 UIView *tempView = [transitionContext containerView].subviews[0]; //动画吧 [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^&#123; //因为present的时候都是使用的transform，这里的动画只需要将transform恢复就可以了 fromVC.view.transform = CGAffineTransformIdentity; tempView.transform = CGAffineTransformIdentity; tempView.layer.cornerRadius = 0; &#125; completion:^(BOOL finished) &#123; if ([transitionContext transitionWasCancelled]) &#123; //失败了标记失败 [transitionContext completeTransition:NO]; &#125;else&#123; //如果成功了，我们需要标记成功，同时让vc1显示出来，然后移除截图视图， [transitionContext completeTransition:YES]; toVC.view.hidden = NO; [tempView removeFromSuperview]; &#125; &#125;];&#125;@end HYInteractiveTransition - Dismiss手势交互管理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//HYInteractiveTransition.h#import &lt;UIKit/UIKit.h&gt;@interface HYInteractiveTransition : UIPercentDrivenInteractiveTransition//是否是正在交互中@property (nonatomic, assign) BOOL interacting;- (void)wireToViewController:(UIViewController*)viewController;@end//HYInteractiveTransition.m#import &quot;HYInteractiveTransition.h&quot;@interface HYInteractiveTransition()@property (nonatomic, assign) BOOL shouldComplete;@property (nonatomic, strong) UIViewController *presentingVC;@end@implementation HYInteractiveTransition- (void)wireToViewController:(UIViewController*)viewController &#123; self.presentingVC = viewController; [self prepareGestureRecognizerInView:viewController.view];&#125;- (void)prepareGestureRecognizerInView:(UIView*)view &#123; UIPanGestureRecognizer *gesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handleGesture:)]; [view addGestureRecognizer:gesture];&#125;- (void)handleGesture:(UIPanGestureRecognizer *)gestureRecognizer &#123; CGPoint translation = [gestureRecognizer translationInView:gestureRecognizer.view]; switch (gestureRecognizer.state) &#123; case UIGestureRecognizerStateBegan: //1.标记交互标志。 在委托中提供时使用。 self.interacting = YES; [self.presentingVC dismissViewControllerAnimated:YES completion:nil]; break; case UIGestureRecognizerStateChanged: &#123; // 2. 计算手势的百分比 CGFloat fraction = translation.y / gestureRecognizer.view.frame.size.height;; //限制在0和1之间 fraction = fminf(fmaxf(fraction, 0.0), 1.0); self.shouldComplete = (fraction &gt; 0.3); [self updateInteractiveTransition:fraction]; &#125; break; case UIGestureRecognizerStateEnded: case UIGestureRecognizerStateCancelled: &#123; //3.手势交互结束。检查转换是否应该发生 self.interacting = NO; if (!self.shouldComplete || gestureRecognizer.state == UIGestureRecognizerStateCancelled) &#123; [self cancelInteractiveTransition]; &#125; else &#123; [self finishInteractiveTransition]; &#125; &#125; break; default: break; &#125;&#125;@end 然后在VC1中实现下面的方法（这里就姑且叫VC1吧，逻辑关系是：从VC1跳转到VC2): 123456789101112131415- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source &#123; return self.presentAnimation;&#125;- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed &#123; return self.dismissAnimation;&#125;//- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForPresentation:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator &#123;////&#125;//- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator &#123; return self.transitionController.interacting ? self.transitionController : nil;&#125; 其中，self.presentAnimation、self.dismissAnimation、self.transitionController是我定义的属性，因为我没有实现从VC1弹出VC2的手势交互，所以我把这个方法注释掉了。 123@property (nonatomic, strong) HYPresentAnimation *presentAnimation;@property (nonatomic, strong) HYDismissAnimation *dismissAnimation;@property (nonatomic, strong) HYInteractiveTransition *transitionController; 最后别忘了实现transitioningDelegate，要想Dismiss的时候就可以直接手指下滑就可以了。 123456- (void)btnClicked:(UIButton *)sender &#123; HYSecondVC *tempVC = [[HYSecondVC alloc]init]; tempVC.transitioningDelegate = self; [self.transitionController wireToViewController:tempVC]; [self presentViewController:tempVC animated:YES completion:nil];&#125; 我已经把我的Demo放在了Github上，有需要的可以看看。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://xuhaoyucn.com/categories/iOS/"}],"tags":[{"name":"模态弹出的转场动画","slug":"模态弹出的转场动画","permalink":"https://xuhaoyucn.com/tags/模态弹出的转场动画/"}]},{"title":"第一篇","slug":"开篇第一篇","date":"2018-09-29T06:02:31.000Z","updated":"2018-09-29T06:55:48.914Z","comments":true,"path":"2018/09/29/开篇第一篇/","link":"","permalink":"https://xuhaoyucn.com/2018/09/29/开篇第一篇/","excerpt":"在某种机缘巧合之下，接触了个人博客 Octopress，然后就很感兴趣，就想的搭建属于自己的个人博客，以此来激励自己更努力的学习。 然后我就查找了好多关于 Octopress 的文章，不过后来看到了 Hexo ，发现 Hexo 的博客主题比 Octopress 多很多也很好看于是上网找了Hexo博客的搭建方法。 于是我的\b第一个个人博客就这样出现了，当然期间也花费了很多时间和精力，每天提前三个多小时到公司连续弄了三四天。还好，结果还是让人很满意的！","text":"在某种机缘巧合之下，接触了个人博客 Octopress，然后就很感兴趣，就想的搭建属于自己的个人博客，以此来激励自己更努力的学习。 然后我就查找了好多关于 Octopress 的文章，不过后来看到了 Hexo ，发现 Hexo 的博客主题比 Octopress 多很多也很好看于是上网找了Hexo博客的搭建方法。 于是我的\b第一个个人博客就这样出现了，当然期间也花费了很多时间和精力，每天提前三个多小时到公司连续弄了三四天。还好，结果还是让人很满意的！ ps：本人是在公司工作不是那么忙的时候弄的，如果你们公司的事情很多，我建议各位还是有空的时候在弄吧。毕竟有些东西还是要深入的了解一下的。 在写这篇博客的时候有想过把我学习搭建博客的方法分享给大家，但是发现关于 Hexo+Github 搭建博客的方法有很多，所以我也就没有\b写下来。不过我还是把我参考的方法\b\b链接分享给大家吧： 搭建方法： https://blog.csdn.net/qq_34290780/article/details/78230706 我用的主题是： - “pure” https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md 可以根据以上的方法搭建自己的博客主题 现在写个博客感觉好像又回到了高中写作文的时候，\b本来就偏科文采不是很好，所有就先写到这吧… 对了，我以后会把我的学习成果和总计、学到的新的技术、封装的框架或控件的思路都写在博客里面，会不定时的更新出来，希望\b有什么不足的可以指出来，有什么需要指点的也可以联系我，我会尽力帮助你。欢迎各位不吝赐教，共同学习，一起成长！","categories":[{"name":"个人总结","slug":"个人总结","permalink":"https://xuhaoyucn.com/categories/个人总结/"}],"tags":[{"name":"感悟","slug":"感悟","permalink":"https://xuhaoyucn.com/tags/感悟/"}]}]}